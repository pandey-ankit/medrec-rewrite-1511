<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<style type="text/css">
  .style1 {
    font-family: "Courier New", Courier, mono
  }
</style>

<head>
  <title>Entities and Value Objects</title>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
  <link href="../../../docs/css/samples.css" rel="stylesheet" title="Style" type="text/css"/>
  <script language="JavaScript" src="../../../docs/core/topicInfo.js"></script>
  <script language="JavaScript" src="../../../docs/core/CookieClass.js" type="text/JavaScript"></script>
  <script language="JavaScript" src="../../../docs/core/displayContent.js" type="text/JavaScript"></script>
  <a href="../../../docs/core/index.html"></a>
</head>

<body>

<script language="JavaScript" type="text/javascript">
  displayInFrames();
</script>

<h1>
  <script language="JavaScript" type="text/JavaScript">document.write(document.title); </script>
</h1>
<p>In traditional Java EE, entity beans are thin objects and responsible only for encapsulating business data; the
  actual business logic is left to session beans. In this approach, state and behavior are isolated, which means that
  the design is not truly object-oriented and applications that use this design cannot handle complex business logic
  very well. </p>

<p>In MedRec, <code>entities</code> and <code>value objects</code> are both fine-grained rich objects that contain the
  business data as well as the business logic associated with the instances. They do not contain, however, the
  class-level business logic or logic that depends on gateways, repositories, and so on; rather, such logic is
  contained in the SLSB <code>services</code>. The main difference between <code>entity</code> and <code>value
    object</code> is that the former has a distinct identity while the latter does not.</p>

<p>Nearly all the <code>entities</code> and <code>value objects</code> in MedRec are JPA mapped objects. In general, the
  <code>entities</code> are annotated with <span class="style1">@Entity</span> and the <code>value objects</code> are
  annotated with <span class="style1">@Embeddable</span>, which means that both of them will be persisted to a
  database. The inheritance feature of object-oriented programming is used heavily in these objects, so that we can
  define the common properties and operations (or just marker interfaces) in the abstract base classes, and then reuse
  them in the concrete classes, significantly simplifying the overall implementations.The base <code>entities</code>
  are annotated with <span class="style1">@MappedSuperclass</span>; they do not make use of the inheritance mapping
  strategies of JPA, because MedRec does not require the polymorphism of <code>entities</code>, and through the
  inheritance we do nothing other than reuse class definitions. </p>

<p>The following diagram illustrates a typical inheritance hierarchy in MedRec:</p>

<p><img width="400" height="481" src="inheritance.jpg"/></p>

<p>The following JPA best practices are adopted in the <code>entities</code> and <code>value objects</code>: </p>
<ul>
  <li><strong>Named Query</strong>: Named queries are used whenever possible in MedRec, providing the following
    benefits: pre-compilation of named queries to improve performance; ability to define the query strings in one
    place and reuse them everywhere; avoidance of the SQL injection attacks. In MedRec, the names of the named
    queries follow the pattern <span class="style1">entity_name.query_name</span> to ensure the readability of the
    code.
  </li>
  <li><strong>Equals and hashcode methods</strong>: All <code>entities</code> and <code>value objects</code> include
    these two methods because it is considered a best practice and is necessary for the detached
    <code>entities</code> that can be put into collections. MedRec does not use the primary keys generated by the
    database to test the equality and calculate the hash code, but instead uses the business keys. This is because
    the primary keys are not available for transient <code>entities</code>.
  </li>
  <li><strong>Bean Validation</strong>: Most of <code>entities</code> and <code>value objects</code> include
    annotations of JavaBean Validation. In Java EE environments, Bean Validation integrates with Java EE containers
    and services to allow developers to easily define and enforce validation constraints.
  </li>
</ul>

<p>&nbsp; </p>
<hr/>
<p>Copyright Â© 1996, 2019, Oracle and/or its affiliates. All rights
  reserved. </p>

</body>
</html>
